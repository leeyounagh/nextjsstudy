# SSR

1. php,루비,파이썬과 같은 언어처럼 html페이지를 웹 브라우저로 전송하기 전에 서버에서 전부 렌더링 할수 있다.
2. 서버에서 렌더링한 페이지에 스크립트 코드를 집어넣어서 나중에 웹 페이지를 동적으로 처리할 수도 있는데 이를 **하이드레이션**이라고 한다.
3. 하이드레이션이 가능한 덕분에 싱글페이지 어플리케이션(spa)처럼 작동할 수 있다. 이로 인하여 csr과 ssr의 장점을 모두 가지게 된다.

## next js의 장점

1. 페이지를 서버에서 렌더링한다는 것은 쿠키관리, 주요 api, 데이터 검증 등과 같은 작업을 서버에서 처리한다는 뜻이며, 중요한 데이터를 클라이언트에 노출할 필요가 없기 때문에 더 안전하다.
2. 클라이언트 환경이 자바스크립트를 사용하지 못하거나, 오래된 브라우저를 사용하더라도 웹 페이지를 제공할 수 있습니다.
3. 클라이언트에서 서버가 렌더링한 html 콘텐츠를 받기 때문에 봇이나 웹 크롤러 같은 검색 엔진 웹 문서 수집기가 페이지를 렌더링할 필요가 없다. 이로 인하여 seo 점수가 높아진다.

## ssr이 최적의 렌더링 전략이 아닌경우

1. 웹 앱을 서버에 배포한다면 다른 방식보다 ssr 애플리케이션이 더 많은 자원을 소모하고 더많은 부하를 보이며 유지보수 비용도 증가한다.
2. 페이지에 대한 요청을 처리하는 시간이 길어진다.(페이지가 외부 api또는 데이터 소스에 접근해야 한다면 해당 페이지를 렌더링할 때마다 api나 데이터 소스를 다시 요청하게 된다. 따라서 정적으로 생성한 페이지간의 이동보다 느리게 된다.) 이를 보완하기위하여 네비게이션 성능을 향상시킬 수 있는 좋은기능을 제공하고 있다.

## getServerSideProps

1. 페이지에 대한 요청이 들어오면 서버가 rest api를 호출해서 필요한 사용자 정보를 가져온다.
2. getServerSideProps라는 비동기 함수를 익스포트한다. 빌드 과정에서 next js는 이함수를 익스포트하는 모든 페이지를 찾아서 서버가 페이지 요청을 처리할때 getServerSideProps 함수를 호출하도록 만든다. 해당 함수 내의 코드는 항상 서버에서만 실행된다.
3. getServerSideProps 함수는 props라는 속성값을 갖는 객체를 반환 한다. next js는 이 props를 컴포넌트로 전달하여 서버와 클라이언트 모두가 props에 접근하고 사용할수 있다.
4. IndexPage 함수를 수정해서 props를 인자로 받습니다. 이 props는 getServerSideProps함수에서 반환한 props의 모든 내용을 가지고 있다.

**주의점**

브라우저 전용 api를 사용해야 하는 컴포넌트가 있다면 해당 컴포넌트를 반드시 브라우저에서 렌더링하도록 명시적으로 지정해야 한다. 이유는 서버에서 렌더링하기 때문에 window,document와 같은 객체나 api를 제공하지 않는다. 이때는 csr이 필요하다.

### CSR

1. 브라우저 화면을 새로 고칠 필요 없이 다른 페이지로의 이동을 가능하게 만든다. 따라서 페이지 간 전환에 멋진 효과를 쉽게 넣을 수 있다.
2. csr을 사용하면 최소한 필요한 html 마크업만 렌더링 한다. 사용자가 버튼을 클릭하면 보이는 모달의 경우 실제 html 페이지에서는 html 마크업으로 존재하지 않는다. 버튼을 클릭해야만 리액트가 동적으로 생성하기 때문!
3. 서버 부하가 감소되고, aws lamda나 firebase와 같은 서버리스 환경에서 웹 앱을 제공할 수도 있다.

### csr의 단점

1. seo에 영향을준다.
2. 네트워크 속도가 느린 환경에서는 css파일을 받는 것에만 수 초가 소요 될수 있다.

## useEffect

브라우저에서만 동작하는 document, window,canvas태그와 같은 요소들은 node js에서 제공하지 않는다. 이는 useEffect 훅으로 감싸서 해결할수 있다.

### process.browser변수

브라우저 전용 api로 인한 문제를 process.browser 변수를 이용하여 조건별로 실행하면 동일하게 해결 가능하바. 이 변수는 boolean값으로, 코드를 클라이언트에서 실행하면 true, 서버에서 실행하면 false값을 가진다. 그러나 이 변수는 지원이 중단될 예정이며, 좀더 정확한 의미를 갖는 typeof window를 사용할수 있다.

## 동적 컴포넌트 로딩

dynamic import를 이용하고, ssr:false 옵션을 줘서 클라이언트에서만 코드를 실행한다고 명시할수 있다. 이로 인하여 서버 부하를 줄이고 애플리케이션을 더 쉽게 확장할수 있다.

## ssg

정적 사이트 생성을 의미한다. 일부 또는 전체 페이지를 빌드 시점에 미리 렌더링 한다.

내용이 거의 변하지 않는 페이지는 ssg를 사용하는것이 좋다.

1. 단순 html 파일이므로 cdn을 통해 파일을 제공하거나 캐시에 저장하기 쉽다. 별도의 연산없이 정적 자원 형태로 제공되기 때문에 서버에 부하를 거의 주지 않는다.
2. 빌드 시점에 html 페이지를 미리 렌더링하기 때문에 페이지를 요청해도 클라이언트나 서버가 무언가를 처리할 필요가 없다. 웹서버는 정적 파일을 보내기만 하고 클라이언트 브라우저는 파일을 받아서 표시만 하면 된다. 서버측에 데이터를 요구하지도 않는다. 정적 html 마크업 내에 미리 렌더링한 내용만 있으면 된다. 따라서 각 요청별로 발생할 수 있는 지연 시간을 최소화 할수 있다.
3. 웹서버가 민감하고 중요한 데이터를 클라이언트로 보낼 필요가 없다. (xss 공격에 유리함) 필요한 모든 정보가 빌드 시점에 미리 페이지로 렌더링 되어 있기 때문이다!.

### isr (Incrematal Static Regeneration)

주기적으로 렌더링 한다, 주체자 서버

ssr은 state값 하나를 수정하기 위해 필요한 데이터를 가져오고 정적 페이지를 다시 생성하는 과정을 반복해야되는 단점이 있다.

### ssg와 isr을 함께 사용하면 좋은 경우

데이터가 자주 변하지 않는 경우에 ssg와 isr을 사용하여 데이터를 원하는 시간동안 캐싱이 가능하다.

![캡처.PNG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5b662e87-18a9-426e-92ce-5e308f6fed16/%EC%BA%A1%EC%B2%98.png)
