## 메타데이터

- 메타 데이터를 제공하지 않으면 웹 사이트가 꼭 필요한 정보를 제공하지 않는다고 생각해서 검색 엔진이 해당 페이지의 점수를 낮게 매길것 이다.
- 메타 태그를 이용해서 브라우저가 사용자 경험을 최적화할 수 있는데 당연히 메타데이터가 없다면 사용자 경험 또한 좋아질 수 없다.

### next js에서의 메타데이터

- next js는 내장 head 컴포넌트를 제공하여 이러한 데이터를 쉽게 다룰 수 있게 도와준다. 이 컴포넌트는 어떤 컴포넌트 에서든 html페이지의 head 내부 데이터를 변경할 수 있도록 해준다. 즉 동적으로 메타데이터, 링크,스크립트 등의 정보를 변경하고, 추가하고, 삭제할 수 있다.

예시)

```jsx
import Head from "next/head";

function IndexPage() {
  return (
    <>
      <Head>
        <title> welcome to my Next.js website</title>
      </Head>
    </>
  );
}
```

## 공통 메타 태그 그룹

같은 태그를 다루는 페이지나 컴포넌트를 여러개 만드는 경우가 있다. 이 경우에는 공통 head 메타 태그를 다루는 하나 또는 여러 개의 컴포넌트를 만드는 것이 좋다.

예시 코드)

```jsx
import Head from "next/head";

function PostMeta(props) {
  return (
    <Head>
      <title>{props.title}</title>
      <meta name="description" content={props.subtitle} />
      <meta property="og:title" contnent={props.title} />
      <meta property="og:description" contnent={props.subtitle} />
      <meta name="twitter:card" content="summary" />
    </Head>
  );
}
```

위와 같이 컴포넌트를 만들고, 아래와 같이 불러와서 쓰면 된다.

```jsx
import posts from "../../data/posts";
export function getServerSideprops({params}){
 const {slug} =params;
const post =posts.find((p) => p.slug ===slug);
return {
props:{{
post
}
}

function Post({post}){
  return(
  <div>
 <PostHead {...post}/>
</div>
)
}
}
```

## 코드 구성과 데이터 불러오기

### 1. 디렉터리 구조 구성

코드를 쉽게 유지 보수하고 확장하려면 프로젝트의 디렉터리 구조를 간결하고 분명하게 구성하고 유지하는 것이 무엇보다 중요하다.

**next js 기본 폴더 구조**

```jsx
- node_modules/
- package.json
- pages/
- public/
- styles/
```

public과 node_modules/디렉터리를 제외한 다른 디렉터리를 모드 src/ 디렉터리 아래로 옮길 수 있다. 다만 프로젝트 내에 pages/와 src/pages 디렉터리가 둘 다 있는 경우 next.js가 src/pages/ 디렉터리를 무시한다는 점을 기억해야된다. 이유는 최상위에 있는 pages/ 디렉터리의 우선순위가 더 높기 때문이다.

### 컴포넌트 구성

- 먼저 컴포넌트들을 세 가지로 분류하고 각 컴포넌트와 관련된 스타일 및 테스트 파일을 같은곳에 두어야 한다. 이를 위해 다음과 같이 components/ 디렉터리를 만들고 그안에 추가 디렉터리를 만든다.
- 코드를 더 효율적으로 구성하기 위해 **아토믹 디자인 원칙**에 따라 각 컴포넌트를 서로 다른 수준의 디렉터리에 둔다. 이는 많이 사용되는 방식이며 이 외에도 다양한 방법으로 코드를 구성할 수 있다. 여기서는 컴포넌트를 다음과 같이 네 가지 종류로 나눈다.

1. **atoms**

코드에서 사용되는 가장 기본적인 컴포넌트들이다. button,input,p와 같은 표준 html 요소를 감싸는 용도로 사용되거나, 애니메이션 또는 컬러 팔레트 등과 같은 용도로 사용되는 컴포넌트를 이곳에 저장한다.

1. **molecules**

atoms에 속한 컴포넌트 여러 개를 조합하여 좀 더 복잡한 구조를 만드는 컴포넌트들이다. 유틸리티 기능들은 많이 사용되지 않는다. 예를 들어 input과 label 컴포넌트를 가져와서 새로운 컴포넌트를 만들면 이 컴포넌트는 molecules에 속한다.

1. **organisms**

molecules와 atoms를 섞어서 더 복잡한 구조의 컴포넌트를 만든다. 예를 들면 회원 가입 양식이나 푸터, 캐러셀 등이 이에 속한다.

1. **templates**

일종의 페이지 스켈레톤으로 어디에 organisms, atioms, molecules를 배치할지 결정해서 사용자가 접근할 수 있는 페이지를 만든다.

### 유틸리티 구성

컴포넌트를 만들지 않는 코드 파일도 있다. 이를 유틸리티 스크립트라고 한다. 공통함수와 같은것들이 utilities 폴더 내부에 정의되고 사용된다.

### 정적 자원 구성

next js에서는 정적 파일을 쉽게 제공할 수 있다. 제공할 파일을 public/디렉터리 아래에 두면 나머지는 프레임워크가 알아서 해준다.

정적 자원을 구성하기 전에 next.js 애플리케이션에서 어떤 정적 파일을 제공해야 할지 파악할 필요가 있다. 일반적인 웹 사이트에서는 다음과 같은 정적 자원을 사용한다.

- 이미지
- 컴파일한 자바스크립트 파일
- 컴파일한 css 파일
- 아이콘(favicon 및 웹 앱 아이콘)
- mainfest.json, robot.txt 등의 정적 파일

icons/ 디렉터리는 주로 웹 앱 매니페스트 아이콘을 제공할 용도로 사용 된다. 웹 앱 매니페스트는 json 파일로, 앱의 이름이나 모바일 기기에 앱을 설치할 때 표시할 아이콘과 같이 프로그레시브 웹 앱에 관한 유용한 정보를 가지고 있다.

### lib 파일 구성

lib 파일은 서드파티 라이브러리를 감싸는 스크립트를 지친하는 말이다. 유틸리티 스크립트는 범용이기 때문에 컴포넌트나 라이브러리에서 가져다 쓸 수 있지만 lib 파일은 특정 라이브러리에 특화 된것 이다.

## 데이터 불러오기

- next js에서는 클라이언트와 서버 모두에서 데이터를 불러올수 있다.
- next js는 데이터베이스,검색 엔진,외부 api,파일시스템 등과 같이 수많은 외부 소스에서 데이터를 가져올 수 있다.
- next js에서는 전체 애플리케이션의 프런트엔드 영역만 담당하는 것이 좋다. 예를들어 설명해보면, 클라이언트가 nextjs를 이용하여 직접 데이터 베이스에 접근 할수 있으나, 악의적인 사용자가 프레임워크의 알려지지 않은 보안 취약점을 이용해서 데이터에 마음대로 접근하거나 악성 코드를 실행 할수 있다.

### 서버에서 데이터 불러오기

- node js는 웹 브라우저와 달리 자바스크립트 fetch api를 제공하지 않는다. 따라서 서버에서는 두가지 방법으로 http 요청을 만들고 처리할 수 있다.

1. node js의 내장 http 라이브러리를 사용할 수 있다. 간단하며 잘 만들어진 라이브러리지만, 서드파티 http 클라이언트와 비교해보았을 때 설정하고 처리해야 할 작업이 더 많다.
2. http 클라이언트 라이브러리를 사용할 수 있다. 클라이언트 및 서버에서 동일한 api를 사용할 수 있는 axios등이 여기에 해당된다.

**서버에서 데이터를 불러오는 경우**

1. 정적 페이지를 만들때 getStaticProps 함수를 사용해서 빌드 시점에 데이터를 불러올수 있다.
2. 서버가 페이지를 렌더링할때 getServerSideProps를 통해 실행 도중 데이터를 불러올 수도 있다.

**axios를 이용한 통신 방식의 예시 코드**

```jsx
export async function getServerSideProps() {
  const usersReq = await axios.get("url");
  if (userReq.status-- - 404) {
    return {
      notFound: true,
    };
  }
  return {
    props: {
      users: usersReq.data,
    },
  };
}
```

위의 예시코드에서 status가 404일때 nextjs에서는 알아서 기본 404페이지를 표시해 준다.

### 클라이언트가 데이터 불러오기

- 동적 웹 애플리케이션에서는 클라이언트가 데이터를 불러오는 경우가 많다. 하지만 서버가 데이터를 불러오는 것이 좀 더 안전하다. 서버에서 http요청을 보내면 요청을 보내는 api 엔드포인트 주소가 외부에 알려지지 않으며 그외에 전송하는 매개변수값이나 http헤더, 사용자의 인증 토큰값도 외부에 노출하지 않기 때문이다.

**_브라우저에서 http 요청을 보낼때 지켜야할 사항들_**

1. 믿을 수 있는 곳에만 http 요청을 보내야 한다. 누가 api를 개발하고 제공하는지, 적용된 보안 규칙이나 표준이 무엇인지를 꼭 확인해야 한다.
2. ssl 인증서를 통해 안전하게 접근할 수 있는 곳의 http api만 사용해야 된다. 원격 api 제공 측이 https를 사용하지 않는다면 중간자 공격과 같은 다양한 보안 공격에 노출될 수 있으며 악의적인 사용자가 이를 이용해 사용자와 서버 간 데이터를 가로채거나 훔쳐볼 수 있다.
3. 브라우저에서 원격 데이터 베이스에 직접 연결해서는 안된다. 당연히 연결할 수 없다고 생각할 수도 있지만 자바스크립트 코드로 원격 데이터 베이스에 연결하는 것이 기술적으로 가능 하다. 브라우저가 데이터베이스에 직접 연결되면 악의적인 사용자가 이를 이용해 원격 데이터베이스에 접근할 수 있는 위험성이 증가 한다.

**클라이언트에서 rest api 사용하기**

- 서버가 데이터를 불러오는 것만큼 클라이언트가 데이터를 불러오는 것도 쉽다. 리액트 또는 그외의 자바스크립트 프레임워크와 비슷한 방법으로 브라우저에서 restapi 요청을 주고 받을수 있다.

**악의적인 사용자의 토큰 탈취를 예방할수 있는 방법**

- 컴포넌트 목록을 오직 서버에서만 렌더링하도록 만든다. 그러면 악의적인 사용자가 프라이빗 api를 호출할 수 없으며 비밀 api 토큰값도 알아낼 수 없다. 물론 사용자가 클라이언트에서 버튼을 클릭 했을때 rest api 요청을 보내는 것과 같이 서버에서 렌더링할 수 없는 경우에는 이 방법을 쓸수 없다.
- jwt,api 키 등과 같은 인증 기법을 사용하여 인증되고 권한이 있는 사용자만 특정 api를 사용할 수 있도록 만든다.
- 루비 온 레일즈, 스프링,laravel,nest.js등과 같은 백엔드 프레임워크를 사용한다. 이런 백엔드 프레임웨크는 클라이언트에서 호출할 수 있는 api의 안정성을 높이는 여러 가지 기법을 지원하여 next.js 애플리케이션을 더 안전하게 만들수 있게 해준다.

## GraphQl Api 사용하기

- graphQl을 사용하면 꼭 필요한 데이터만 불러오도록 지정할 수 있으며 한 번의 요청으로 여러 곳의 데이터를 불러 올 수 있다. 또한 사용할 데이터에 대해 정적이면서도 강력한 타입 시스템을 제공하는 등 여러 가지 장점을 지니고 있다.
